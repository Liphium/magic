package tui

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/Liphium/magic/integration"
	"github.com/Liphium/magic/mconfig"
	"github.com/Liphium/magic/mrunner"
)

const defaultScriptRunFile = `// Automagically generated by Magic
package main

import (
	"os"
	"log"
	
	"github.com/Liphium/magic/mconfig"
)

func main() {
	if len(os.Args) < 2 {
		log.Fatalln("Please provide the plan as a command line argument (in printable form).")
	}

	// Parse the plan
	plan, err := mconfig.FromPrintable(os.Args[1])
	if err != nil {
		log.Fatalln("Couldn't parse printable plan:", err)
	}

	// Run the script
	Run%s(plan)
}
`

// Command: run [path]
func RunCommand(fp string, logLeaf *StringLeaf, quitLeaf *Leaf[error]) {
	wOld, err := os.Getwd()
	if err != nil {
		logLeaf.Printlnf("couldn't get working directory: %s", err)
		return
	}

	// Get the magic directory
	mDir, err := integration.GetMagicDirectory(5) // because cwd is inside ./magic/cache/config_default
	if err != nil {
		logLeaf.Printlnf("can't get magic directory: %s", err)
		return
	}
	originalFp := fp
	fp = filepath.Join(mDir, "scripts", fp)

	// Verify the file path
	_, fileName, path, err := integration.EvaluatePath(fp)
	if err != nil {
		logLeaf.Printlnf("can't find %s: %s", fp, err)
		return
	}

	// Run the script
	if err := mrunner.GoToCache(); err != nil {
		logLeaf.Printlnf("can't go to cache: %s", err)
		return
	}

	// Generate the folder for the script
	if err := mrunner.GenerateScriptFolder(strings.ReplaceAll(strings.TrimRight(originalFp, ".go"), "/", "_")); err != nil {
		logLeaf.Printlnf("couldn't generate script folder: %s", err)
		return
	}

	// Copy the script file into the folder
	if err := mrunner.CopyFileAndReplacePackage(path, "magic_scripts", "main"); err != nil {
		logLeaf.Printlnf("couldn't copy script file: %s", err)
		return
	}

	// Copy mod file into the script's execution directory
	version, err := mrunner.GenGoMod(mDir, func(s string) {
		logLeaf.Println(s)
	})
	if err != nil {
		logLeaf.Printlnf("couldn't copy mod file: %s", err)
		return
	}

	// Generate a run file to run the script
	scriptName := strings.TrimRight(fileName, ".go")
	content := fmt.Sprintf(defaultScriptRunFile, integration.SnakeToCamelCase(scriptName, true))
	if err := integration.CreateFileWithContent("run_magic_script.go", content); err != nil {
		logLeaf.Printlnf("couldn't create script run file: %s", err)
		return
	}

	// Update or create work file
	if err := mrunner.HandleWorkFile(version); err != nil {
		logLeaf.Printlnf("couldn't update/create work file: %s", err)
		return
	}

	// Import all dependencies
	if err := mrunner.ImportDependencies(func(s string) {
		logLeaf.Println(s)
	}); err != nil {
		logLeaf.Printlnf("can't import dependencies: %s", err)
		return
	}

	// Run the script
	logLeaf.Printlnf("Executing script %s...", fp)
	printable, err := mconfig.CurrentPlan.ToPrintable()
	if err != nil {
		logLeaf.Printlnf("couldn't stringify plan: %s", err)
		return
	}
	if err := integration.ExecCmdWithFuncStart(func(s string) {
		logLeaf.Println(integration.ColorizeScript(s, filepath.Base(fp), "green"))
	}, func(cmd *exec.Cmd) {
		if err = os.Chdir(wOld); err != nil {
			quitLeaf.Append(fmt.Errorf("ERROR: couldn't change working directory: %s", err))
		}
	}, "go", "run", ".", printable); err != nil {
		logLeaf.Printlnf("couldn't run script: %s", err)
		return
	}
	logLeaf.Printlnf("Successfully executed script %s.", fp)
}
